"""
Numpy's mypy stub. Only type declarations for ndarray, the scalar hierarchy and array creation
methods are provided.
"""

import abc
from typing import (Any, Callable, Dict, Generic, Iterator, List, Optional, Sequence, Tuple, Type,
                    TypeVar, Union)
from pathlib import Path

class dtype:
    def __init__(self, obj, align=False, copy=False): ...
    @property
    def base(self) -> dtype: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def type(self) -> Type: ...
    @property
    def str(self) -> str: ...

_dtype = dtype


class flagsobj:
    """numpy.flagsobj"""
    aligned = None       # type: bool
    behaved = None       # type: bool
    c_contiguous = None  # type: bool
    carray = None        # type: bool
    contiguous = None    # type: bool
    f_contiguous = None  # type: bool
    farray = None        # type: bool
    fnc = None           # type: bool
    forc = None          # type: bool
    fortran = None       # type: bool
    owndata = None       # type: bool
    updateifcopy = None  # type: bool
    writeable = None     # type: bool
    def __getitem__(self, item: str) -> bool: ...
    def __setitem__(self, item: str, value: bool) -> None: ...

#
# Type variables. _T wasn't used to avoid confusions with ndarray's "T" attribute.
#

_S = TypeVar('_S')
_U = TypeVar('_U')
_V = TypeVar('_V')

#
# Auxiliary types
#

ShapeType = Union[int, Sequence[int]]
AxesType = Union[int, Tuple[int, ...]]
OrderType = Union[str, Sequence[str]]
DtypeType = Union[dtype, type]

class flatiter(Generic[_S], Iterator[_S]):
    coords = ...  # type: ShapeType
    def copy(self) -> flatiter[_S]: ...

class _ArrayLike(abc.ABC, Generic[_S]):
    """
    "array-like" interface that both numpy.ndarray and all scalars (descendants of numpy.generic)
    implement this interface.
    """
    #
    # Array-like structures attributes
    #
    @property
    @abc.abstractmethod
    def T(self) -> _ArrayLike[_S]: ...
    @property
    @abc.abstractmethod
    def data(self) -> Any: ...
    @property
    @abc.abstractmethod
    def dtype(self) -> _dtype: ...
    @property
    @abc.abstractmethod
    def flags(self) -> flagsobj: ...
    @property
    @abc.abstractmethod
    def flat(self) -> flatiter[_ArrayLike[_S]]: ...
    @property
    @abc.abstractmethod
    def imag(self) -> _ArrayLike[_S]: ...
    @property
    @abc.abstractmethod
    def real(self) -> _ArrayLike[_S]: ...
    @property
    @abc.abstractmethod
    def size(self) -> int: ...
    @property
    @abc.abstractmethod
    def itemsize(self) -> int: ...
    @property
    @abc.abstractmethod
    def nbytes(self) -> int: ...
    @property
    @abc.abstractmethod
    def ndim(self) -> int: ...
    @property
    @abc.abstractmethod
    def shape(self) -> Tuple[int, ...]: ...
    @property
    @abc.abstractmethod
    def strides(self) -> Tuple[int, ...]: ...
    @property
    @abc.abstractmethod
    def base(self) -> Optional[_ArrayLike[_S]]: ...

    #
    # Array-like methods
    #

    # Once this issue https://github.com/python/mypy/issues/1907 is resolved, most methods that
    # have an 'out' argument, will be implemented using overload instead of with a Union
    # result. mypy is smart enough to assign the proper type (_ArrayLike[_U]) when out is present
    # but it falls back to the union when it's not.
    @abc.abstractmethod
    def all(self, axis: AxesType=None, out: _ArrayLike[_U]=None,
            keepdims: bool=False) -> Union[_ArrayLike[_U], _ArrayLike[bool]]: ...

    @abc.abstractmethod
    def any(self, axis: AxesType=None, out: _ArrayLike[_U]=None,
            keepdims: bool=False) -> Union[_ArrayLike[_U], _ArrayLike[bool]]: ...

    @abc.abstractmethod
    def argmax(self, axis: int=None,
               out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_U], _ArrayLike[int]]: ...

    @abc.abstractmethod
    def argmin(self, axis: int=None,
               out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_U], _ArrayLike[int]]: ...

    @abc.abstractmethod
    def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
                     kind: str='introselect', order: OrderType=None) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def argsort(self, axis: int=None, kind: str='quicksort',
                order: OrderType=None) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def astype(self, dtype: Any, order: str='K', casting: str='unsafe', subok: bool=True,
               copy: bool=False) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def byteswap(self, inplace: bool=False) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def choose(self, choices:Sequence[_ArrayLike[_V]], out: _ArrayLike[_U]=None,
               mode: str='raise') ->  Union[_ArrayLike[_U], _ArrayLike[_V]]: ...

    @abc.abstractmethod
    def clip(self, a_min: Any, a_max: Any,
             out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def compress(self, condition: Sequence[bool], axis: int=None,
                 out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def conj(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def conjugate(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def copy(self, order: str='C') -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def cumprod(self, axis: int=None, dtype: Any=None,
                out: _ArrayLike[Any]=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def cumsum(self, axis: int=None, dtype: DtypeType=None,
                out: _ArrayLike[Any]=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def diagonal(self, offset: int=0, axis1: int=0, axis2: int=1) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def dot(self, b: _ArrayLike[Any], out: _ArrayLike[Any]=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def dump(self, file: str) -> None: ...

    @abc.abstractmethod
    def dumps(self) -> str: ...

    @abc.abstractmethod
    def fill(self, value: _S) -> None: ...

    @abc.abstractmethod
    def flatten(self, order: str='C') -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def getfield(self, dtype: DtypeType, offset: int=0) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def item(self, args: AxesType) -> generic: ...

    @abc.abstractmethod
    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Any=None) -> None: ...

    @abc.abstractmethod
    def max(self, axis: AxesType=None,
            out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def mean(self, axis: AxesType=None, dtype: Any=None,
             out: _ArrayLike[_U]=None, keepdims: bool=False) -> _ArrayLike[floating]: ...

    @abc.abstractmethod
    def min(self, axis: AxesType=None,
            out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def newbyteorder(self, new_order: str='S') -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def nonzero(self) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def partition(self, kth: AxesType, axis: int=-1, kind: str='introselect',
                  order: OrderType=None) -> None: ...

    @abc.abstractmethod
    def prod(self, axis: AxesType=None, dtype: DtypeType=None,
             out: _ArrayLike[_U]=None, keepdims: bool=False) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def ptp(self, axis: int=None,
            out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def put(self, ind: _ArrayLike[int], v: _ArrayLike[_S], mode: str='raise') -> None: ...

    @abc.abstractmethod
    def ravel(self, order: str='C') -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def repeat(self, repeats: Union[int, Sequence[int]],
               axis: int=None) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def reshape(self, newshape: ShapeType, *,
                order: str='C') -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def resize(self, new_shape: ShapeType, refcheck: bool=True) -> None: ...

    @abc.abstractmethod
    def round(self, decimals: int=0,
              out: _ArrayLike[_U]=None) -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def searchsorted(self, v: Union[_S, _ArrayLike[_S]], side: str='left',
                     sorter: _ArrayLike[int]=None) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def setfield(self, val: Any, dtype: DtypeType, offset: int=0) -> None: ...

    @abc.abstractmethod
    def setflags(self, write: bool=None, align: bool=None,
                 uic: bool=None) -> None: ...

    @abc.abstractmethod
    def sort(self, axis: int=-1, kind: str='quicksort', order: OrderType=None) -> None: ...

    @abc.abstractmethod
    def squeeze(self, axis: AxesType=None) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def std(self, axis: AxesType=None, dtype: DtypeType=None,
            out: _ArrayLike[_U]=None, ddof: int=0, keepdims: bool=False) -> _ArrayLike[floating]: ...

    @abc.abstractmethod
    def sum(self, axis: AxesType=None, dtype: DtypeType=None,
            out: _ArrayLike[_U]=None,
            keepdims: bool=False) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def swapaxes(self, axis1: int, axis2: int) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def take(self, indices: Sequence[int], axis: int=None,
             out: _ArrayLike[_U]=None,
             mode: str='raise') -> Union[_ArrayLike[_S], _ArrayLike[_U]]: ...

    @abc.abstractmethod
    def tobytes(self, order: str='C') -> bytes: ...

    @abc.abstractmethod
    def tofile(self, fid: object, sep: str='',  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
               format: str='%s') -> None: ...

    @abc.abstractmethod
    def tolist(self) -> List[Any]: ...

    @abc.abstractmethod
    def tostring(self, order: str='C') -> bytes: ...

    @abc.abstractmethod
    def trace(self, offset: int=0, axis1: int=0, axis2: int=1,
              dtype: DtypeType=None, out: _ArrayLike[_U]=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def transpose(self, axes: Optional[AxesType]) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def var(self, axis: AxesType=None, dtype: DtypeType=None,
            out: _ArrayLike[_U]=None, ddof: int=0, keepdims: bool=False) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def view(self, dtype: Union[DtypeType, Type['ndarray']]=None,
             type: type=None) -> _ArrayLike[Any]: ...

    #
    # Magic methods
    #
    @abc.abstractmethod
    def __abs__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __add__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __and__(self, value: object) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def __array__(self, dtype: DtypeType=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __array_prepare__(self, context: object=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __array_wrap__(self, context: object=None) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __bool__(self) -> bool: ...

    @abc.abstractmethod
    def __complex__(self) -> complex: ...

    @abc.abstractmethod
    def __contains__(self, key: object) -> bool: ...

    @abc.abstractmethod
    def __copy__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __deepcopy__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __delattr__(self, name: str) -> None: ...

    @abc.abstractmethod
    def __delitem__(self, key: str) -> None: ...

    @abc.abstractmethod
    def __dir__(self) -> List[str]: ...

    @abc.abstractmethod
    def __divmod__(self, value: object) -> Tuple[_ArrayLike[int], _ArrayLike[float]]: ...

    @abc.abstractmethod
    def __eq__(self, value: object) -> _ArrayLike[bool]: ...  # type: ignore

    @abc.abstractmethod
    def __float__(self) -> float: ...

    @abc.abstractmethod
    def __floordiv__(self, value: object) -> _ArrayLike[int]: ...

    @abc.abstractmethod
    def __ge__(self, value: object) -> _ArrayLike[bool]: ...

    @abc.abstractmethod
    def __getattribute__(self, name: str) -> Any: ...

    @abc.abstractmethod
    def __getitem__(self, key: Any) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __gt__(self, value: object) -> _ArrayLike[bool]: ...

    @abc.abstractmethod
    def __iadd__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __iand__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __ifloordiv__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __ilshift__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __imatmul__(self, value: _ArrayLike[Any]) -> None: ...

    @abc.abstractmethod
    def __imod__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __imul__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __index__(self) -> int: ...

    @abc.abstractmethod
    def __int__(self) -> int: ...

    @abc.abstractmethod
    def __invert__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __ior__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __ipow__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __irshift__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __isub__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __iter__(self) -> Iterator[_ArrayLike[_S]]: ...

    @abc.abstractmethod
    def __itruediv__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __ixor__(self, value: object) -> None: ...

    @abc.abstractmethod
    def __le__(self, value: object) -> _ArrayLike[bool]: ...

    @abc.abstractmethod
    def __len__(self) -> int: ...

    @abc.abstractmethod
    def __lshift__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __lt__(self, value: object) -> _ArrayLike[bool]: ...

    @abc.abstractmethod
    def __matmul__(self, value: _ArrayLike[Any]) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __mod__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __mul__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __ne__(self, value: object) -> _ArrayLike[bool]: ...  # type: ignore

    @abc.abstractmethod
    def __neg__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __or__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __pos__(self) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __pow__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __radd__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rand__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __rdivmod__(self, value: object) -> Tuple[_ArrayLike[int], _ArrayLike[float]]: ...

    @abc.abstractmethod
    def __rfloordiv__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rlshift__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rmatmul__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rmod__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rmul__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __ror__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __rpow__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rrshift__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rshift__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rsub__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rtruediv__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __rxor__(self, value: object) -> _ArrayLike[_S]: ...

    @abc.abstractmethod
    def __setattr__(self, name: str, value: Any) -> None: ...

    @abc.abstractmethod
    def __setitem__(self, key: Any, value: Any) -> None: ...

    @abc.abstractmethod
    def __str__(self) -> str: ...

    @abc.abstractmethod
    def __sub__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __truediv__(self, value: object) -> _ArrayLike[Any]: ...

    @abc.abstractmethod
    def __xor__(self, value: object) -> _ArrayLike[_S]: ...

#
# numpy's scalar hierarchy (http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#scalars)
#

class generic(abc.ABC, _ArrayLike[_S], Generic[_S]): ...
class bool_(generic[bool]):
    def __init__(self, value:bool=False) -> None: ...
bool8 = bool_
class object_(generic[Any]):
    def __init__(self, value:Any=None) -> None: ...
class number(abc.ABC, generic[_S], Generic[_S]): ...
class integer(abc.ABC, number[int]):
    def __init__(self, value:int=0) -> None: ...
class signedinteger(abc.ABC, integer): ...
class byte(signedinteger): ...
class short(signedinteger): ...
class intc(signedinteger): ...
class int_(signedinteger): ...
class longlong(signedinteger): ...
class int8(signedinteger): ...
class int16(signedinteger): ...
class int32(signedinteger): ...
class int64(signedinteger): ...
class unsignedinteger(integer): ...
class ubyte(unsignedinteger): ...
class ushort(unsignedinteger): ...
class uintc(unsignedinteger): ...
class uint(unsignedinteger): ...
class ulonglong(unsignedinteger): ...
class uint8(signedinteger): ...
class uint16(signedinteger): ...
class uint32(signedinteger): ...
class uint64(signedinteger): ...
class inexact(abc.ABC, number[float]):
    def __init__(self, value:float=0.0) -> None: ...
class floating(abc.ABC, inexact): ...
class half(floating): ...
class single(floating): ...
class float_(floating): ...
class longfloat_(floating): ...
class float16(floating): ...
class float32(floating): ...
class float64(floating): ...
class float128(floating): ...
class complexfloating(abc.ABC, inexact):
    def __init__(self, value:complex=complex(0.0,0.0)) -> None: ...
class csingle(complexfloating): ...
class complex_(complexfloating): ...
class clongfloat(complexfloating): ...
class complex64(complexfloating): ...
class complex128(complexfloating): ...
class complex256(complexfloating): ...
class flexible(abc.ABC, generic[_S], Generic[_S]): ...
class character(abc.ABC,flexible[str]): ...
class str_(character): ...
class unicode_(character): ...
class void(flexible[None]):
    def __init__(self, byte_count:int) -> None: ...

class ndarray(_ArrayLike[_S], Generic[_S]):
    """numpy.ndarray"""
    ctypes = None    # type: Any  # TODO Implement ctypes type hint

    # TODO Need to find a way to restrict buffer type
    def __init__(self, shape: Tuple[int, ...], dtype: DtypeType=None,
                 buffer: Any=None, offset: int=None,
                 strides: Tuple[int, ...]=None, order: str=None) -> None: ...

#
# Array creation routines
#

def array(object: Any, dtype: Any=None, *, copy: bool=True,
          order: str=None, subok: bool=False,
          ndmin: int=0) -> ndarray[Any]: ...
def asarray(a: Any, dtype: DtypeType=None, order: str=None) -> ndarray[Any]: ...
def asanyarray(a: Any, dtype: DtypeType=None, order: str=None) -> ndarray[Any]: ...  # TODO figure out a way to restrict the return type
def asmatrix(data: Any, dtype: DtypeType=None) -> Any: ...  # TODO define matrix
def ascontiguousarray(a: Any, dtype: DtypeType=None) -> ndarray[Any]: ...
def copy(a: Any, order: str=None)	-> ndarray[Any]: ...
def empty(shape: ShapeType, dtype: DtypeType=float, order: str='C') -> ndarray[Any]: ...
def empty_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...
def expand_dims(a: ndarray[_S], axis: int) -> ndarray[_S]: ...
def eye(N: int, M: int=None, k: int=0, dtype: DtypeType=float) -> ndarray[Any]: ...
def frombuffer(buffer: Any, dtype: DtypeType=float, count: int=-1,  # TODO figure out a way to restrict buffer
               offset: int=0) -> ndarray[Any]: ...
def fromfile(file: object, dtype: DtypeType=float, count: int=-1, sep: str='') -> ndarray[Any]: ...  # TODO fix file definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
def full(shape: ShapeType, fill_value: Any, dtype: DtypeType=None,
         order: str='C') -> ndarray[Any]: ...
def full_like(a: Any, fill_value: Any, dtype: DtypeType=None, order: str='C',
              subok: bool=True) -> ndarray[Any]: ...
def fromfunction(function: Callable[..., _S], shape: ShapeType, dtype: DtypeType=float) -> ndarray[_S]: ...
def fromiter(iterable: Iterator[Any], dytpe: DtypeType, count: int=-1) -> ndarray[Any]: ...
def fromstring(string: str, dtype: DtypeType=float, count: int=-1, sep: str='') -> ndarray[Any]: ...
def identity(n: int, dtype: DtypeType=float) -> ndarray[Any]: ...
def loadtxt(fname: Any, dtype: DtypeType=float, comments: Union[str, Sequence[str]]='#',
            delimiter: str=None, converters: Dict[int, Callable[[Any], float]]=None,
            skiprows: int=0, usecols: Sequence[int]=None,
            unpack: bool=False, ndmin: int=0) -> ndarray[float]: ...
def ones(shape: ShapeType, dtype: Optional[DtypeType]=float64, order: str='C') -> ndarray[Any]: ...
def ones_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...
def split(ary: ndarray[_S], indices_or_sections: Union[int, list[int]], axis:int=0) -> list[ndarray[_S]]: ...
def zeros(shape: ShapeType, dtype: DtypeType=float, order: str='C') -> ndarray[Any]: ...
def zeros_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...

# TODO: file can be Path or file descriptor too
def load(file: str, mmap_mode: Optional[Union[None, 'r+', 'r', 'w+', 'c']]=None, allow_pickle: bool=True, fix_imports: bool = None) -> _ArrayLike: ...
def save(file: str, array: _ArrayLike, allow_pickle: bool=True, fix_imports: bool = None): ...


# Specific values
inf: float

# numpy re-exports these built-in types
from builtins import bool, complex, float, int, object, str